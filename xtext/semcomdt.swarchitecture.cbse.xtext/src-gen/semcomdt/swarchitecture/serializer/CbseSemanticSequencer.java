/*
 * generated by Xtext 2.35.0
 */
package semcomdt.swarchitecture.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import semcomdt.swarchitecture.cbse.ActiveComponent;
import semcomdt.swarchitecture.cbse.Cbse;
import semcomdt.swarchitecture.cbse.CbsePackage;
import semcomdt.swarchitecture.cbse.CommunicationStyle;
import semcomdt.swarchitecture.cbse.Connector;
import semcomdt.swarchitecture.cbse.Data;
import semcomdt.swarchitecture.cbse.DataType;
import semcomdt.swarchitecture.cbse.Function;
import semcomdt.swarchitecture.cbse.InteractionNature;
import semcomdt.swarchitecture.cbse.MsgExchange;
import semcomdt.swarchitecture.cbse.PassiveComponent;
import semcomdt.swarchitecture.cbse.Payload;
import semcomdt.swarchitecture.cbse.Port;
import semcomdt.swarchitecture.services.CbseGrammarAccess;

@SuppressWarnings("all")
public class CbseSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CbseGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CbsePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CbsePackage.ACTIVE_COMPONENT:
				sequence_ActiveComponent(context, (ActiveComponent) semanticObject); 
				return; 
			case CbsePackage.CBSE:
				sequence_Cbse(context, (Cbse) semanticObject); 
				return; 
			case CbsePackage.COMMUNICATION_STYLE:
				sequence_CommunicationStyle(context, (CommunicationStyle) semanticObject); 
				return; 
			case CbsePackage.CONNECTOR:
				sequence_Connector(context, (Connector) semanticObject); 
				return; 
			case CbsePackage.DATA:
				sequence_Data(context, (Data) semanticObject); 
				return; 
			case CbsePackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case CbsePackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case CbsePackage.INTERACTION_NATURE:
				sequence_InteractionNature(context, (InteractionNature) semanticObject); 
				return; 
			case CbsePackage.MSG_EXCHANGE:
				sequence_MsgExchange(context, (MsgExchange) semanticObject); 
				return; 
			case CbsePackage.PASSIVE_COMPONENT:
				sequence_PassiveComponent(context, (PassiveComponent) semanticObject); 
				return; 
			case CbsePackage.PAYLOAD:
				sequence_Payload(context, (Payload) semanticObject); 
				return; 
			case CbsePackage.PORT:
				sequence_Port(context, (Port) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns ActiveComponent
	 *     Component returns ActiveComponent
	 *     ActiveComponent returns ActiveComponent
	 *
	 * Constraint:
	 *     (name=ID functions+=Function*)
	 * </pre>
	 */
	protected void sequence_ActiveComponent(ISerializationContext context, ActiveComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Cbse returns Cbse
	 *
	 * Constraint:
	 *     system+=Element+
	 * </pre>
	 */
	protected void sequence_Cbse(ISerializationContext context, Cbse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CommunicationStyle returns CommunicationStyle
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_CommunicationStyle(ISerializationContext context, CommunicationStyle semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CbsePackage.Literals.COMMUNICATION_STYLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CbsePackage.Literals.COMMUNICATION_STYLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommunicationStyleAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Connector
	 *     Connector returns Connector
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Connector(ISerializationContext context, Connector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CbsePackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CbsePackage.Literals.ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConnectorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CbsePackage.Literals.DATA_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CbsePackage.Literals.DATA_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Data returns Data
	 *
	 * Constraint:
	 *     (name=ID superType=[InteractionNature|ID])
	 * </pre>
	 */
	protected void sequence_Data(ISerializationContext context, Data semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CbsePackage.Literals.DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CbsePackage.Literals.DATA__NAME));
			if (transientValues.isValueTransient(semanticObject, CbsePackage.Literals.DATA__SUPER_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CbsePackage.Literals.DATA__SUPER_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDataAccess().getSuperTypeInteractionNatureIDTerminalRuleCall_2_1_0_1(), semanticObject.eGet(CbsePackage.Literals.DATA__SUPER_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CbsePackage.Literals.FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CbsePackage.Literals.FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InteractionNature returns InteractionNature
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_InteractionNature(ISerializationContext context, InteractionNature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CbsePackage.Literals.INTERACTION_NATURE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CbsePackage.Literals.INTERACTION_NATURE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInteractionNatureAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MsgExchange returns MsgExchange
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_MsgExchange(ISerializationContext context, MsgExchange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CbsePackage.Literals.MSG_EXCHANGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CbsePackage.Literals.MSG_EXCHANGE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMsgExchangeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns PassiveComponent
	 *     Component returns PassiveComponent
	 *     PassiveComponent returns PassiveComponent
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_PassiveComponent(ISerializationContext context, PassiveComponent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CbsePackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CbsePackage.Literals.ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPassiveComponentAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Payload returns Payload
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Payload(ISerializationContext context, Payload semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CbsePackage.Literals.PAYLOAD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CbsePackage.Literals.PAYLOAD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPayloadAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Port
	 *     Port returns Port
	 *
	 * Constraint:
	 *     (name=ID kind=PortKind interactionNature=InteractionNature?)
	 * </pre>
	 */
	protected void sequence_Port(ISerializationContext context, Port semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
